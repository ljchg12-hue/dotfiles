#!/usr/bin/env bash
# claude-init - Generate project-specific CLAUDE.md
# Version: 2.0.0

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Paths
TEMPLATE_DIR="${HOME}/.claude/templates"
UNIVERSAL_TEMPLATE="${HOME}/.claude/UNIVERSAL_CLAUDE_TEMPLATE.md"
PROJECT_DIR="${1:-.}"

# Helper functions
print_header() {
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘   Claude Code Project Initializer     â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

print_error() {
    echo -e "${RED}âŒ $1${NC}"
}

print_info() {
    echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

# Detect project type and tech stack
detect_project() {
    local project_dir="$1"
    local project_type="application"
    local languages=()
    local frameworks=()
    local tools=()

    cd "$project_dir" || exit 1

    # Detect languages
    [[ -f "Cargo.toml" ]] && languages+=("rust")
    [[ -f "package.json" ]] && languages+=("typescript" "javascript")
    [[ -f "pyproject.toml" || -f "setup.py" || -f "requirements.txt" ]] && languages+=("python")
    [[ -f "go.mod" ]] && languages+=("go")
    [[ -f "pom.xml" || -f "build.gradle" ]] && languages+=("java")

    # Detect frameworks
    if [[ -f "package.json" ]]; then
        grep -q '"react"' package.json 2>/dev/null && frameworks+=("react")
        grep -q '"next"' package.json 2>/dev/null && frameworks+=("nextjs")
        grep -q '"express"' package.json 2>/dev/null && frameworks+=("express")
        grep -q '"fastify"' package.json 2>/dev/null && frameworks+=("fastify")
    fi

    if [[ -f "Cargo.toml" ]]; then
        grep -q "axum" Cargo.toml 2>/dev/null && frameworks+=("axum")
        grep -q "actix-web" Cargo.toml 2>/dev/null && frameworks+=("actix")
        grep -q "rocket" Cargo.toml 2>/dev/null && frameworks+=("rocket")
    fi

    if [[ -f "requirements.txt" || -f "pyproject.toml" ]]; then
        grep -qE "fastapi|uvicorn" requirements.txt pyproject.toml 2>/dev/null && frameworks+=("fastapi")
        grep -q "django" requirements.txt pyproject.toml 2>/dev/null && frameworks+=("django")
        grep -q "flask" requirements.txt pyproject.toml 2>/dev/null && frameworks+=("flask")
    fi

    # Detect tools
    [[ -f "Dockerfile" ]] && tools+=("docker")
    [[ -f "docker-compose.yml" ]] && tools+=("docker-compose")
    [[ -d ".github/workflows" ]] && tools+=("github-actions")
    [[ -f ".gitlab-ci.yml" ]] && tools+=("gitlab-ci")
    [[ -f "Makefile" ]] && tools+=("make")

    # Detect project type
    if grep -qE "\"type\".*\"library\"|\\[lib\\]" Cargo.toml package.json 2>/dev/null; then
        project_type="library"
    elif [[ -f "nx.json" || -f "lerna.json" || -f "pnpm-workspace.yaml" ]]; then
        project_type="monorepo"
    fi

    echo "$project_type|${languages[*]}|${frameworks[*]}|${tools[*]}"
}

# Interactive setup
interactive_setup() {
    local project_info
    project_info=$(detect_project "$PROJECT_DIR")
    IFS='|' read -r detected_type detected_langs detected_frameworks detected_tools <<< "$project_info"

    echo ""
    print_info "Detected configuration:"
    echo "  Project Type: $detected_type"
    echo "  Languages: ${detected_langs:-none}"
    echo "  Frameworks: ${detected_frameworks:-none}"
    echo "  Tools: ${detected_tools:-none}"
    echo ""

    # Project name
    default_name=$(basename "$(realpath "$PROJECT_DIR")")
    read -rp "ðŸ“¦ Project name [$default_name]: " project_name
    project_name=${project_name:-$default_name}

    # Project type
    echo ""
    echo "ðŸ“‹ Project type:"
    echo "  1) Application (default)"
    echo "  2) Library"
    echo "  3) Service/API"
    echo "  4) Monorepo"
    read -rp "Select [1-4, default: auto-detected as $detected_type]: " type_choice
    case ${type_choice:-0} in
        1) project_type="application" ;;
        2) project_type="library" ;;
        3) project_type="service" ;;
        4) project_type="monorepo" ;;
        *) project_type="$detected_type" ;;
    esac

    # Methodologies
    echo ""
    echo "ðŸŽ¯ Development methodologies (space-separated numbers):"
    echo "  1) TDD (Test-Driven Development)"
    echo "  2) BDD (Behavior-Driven Development)"
    echo "  3) DDD (Domain-Driven Design)"
    echo "  4) Clean Code principles"
    echo "  5) Agile/Scrum"
    read -rp "Select methodologies [1 4]: " methodology_choice
    methodology_choice=${methodology_choice:-"1 4"}

    methodologies=()
    for choice in $methodology_choice; do
        case $choice in
            1) methodologies+=("tdd") ;;
            2) methodologies+=("bdd") ;;
            3) methodologies+=("ddd") ;;
            4) methodologies+=("clean-code") ;;
            5) methodologies+=("agile") ;;
        esac
    done

    # Commit convention
    echo ""
    echo "ðŸ“ Commit message convention:"
    echo "  1) Conventional Commits (default)"
    echo "  2) Custom"
    read -rp "Select [1-2]: " commit_choice
    case ${commit_choice:-1} in
        1) commit_convention="conventional-commits" ;;
        2) commit_convention="custom" ;;
        *) commit_convention="conventional-commits" ;;
    esac

    # Quality gates
    echo ""
    read -rp "ðŸ“Š Minimum test coverage (%)? [80]: " min_coverage
    min_coverage=${min_coverage:-80}

    # Generate CLAUDE.md
    generate_claude_md "$project_name" "$project_type" "$detected_langs" \
        "$detected_frameworks" "$detected_tools" "${methodologies[*]}" \
        "$commit_convention" "$min_coverage"
}

# Generate CLAUDE.md
generate_claude_md() {
    local project_name="$1"
    local project_type="$2"
    local languages="$3"
    local frameworks="$4"
    local tools="$5"
    local methodologies="$6"
    local commit_convention="$7"
    local min_coverage="$8"

    local output_file="${PROJECT_DIR}/CLAUDE.md"

    # Check if file exists
    if [[ -f "$output_file" ]]; then
        print_warning "CLAUDE.md already exists in $PROJECT_DIR"
        read -rp "Overwrite? [y/N]: " overwrite
        if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
            print_info "Aborting. Backup created at CLAUDE.md.bak"
            cp "$output_file" "${output_file}.bak"
            return 1
        fi
        cp "$output_file" "${output_file}.bak"
        print_info "Backup created at CLAUDE.md.bak"
    fi

    # Copy template
    if [[ ! -f "$UNIVERSAL_TEMPLATE" ]]; then
        print_error "Universal template not found at $UNIVERSAL_TEMPLATE"
        return 1
    fi

    cp "$UNIVERSAL_TEMPLATE" "$output_file"

    # Replace placeholders
    local current_date
    current_date=$(date +"%Y-%m-%d")

    # Format language array
    local lang_array
    lang_array=$(echo "$languages" | awk '{for(i=1;i<=NF;i++) printf "\"%s\"%s", $i, (i==NF?"":", ")}')

    # Format frameworks array
    local fw_array
    fw_array=$(echo "$frameworks" | awk '{for(i=1;i<=NF;i++) printf "\"%s\"%s", $i, (i==NF?"":", ")}')

    # Format methodologies enabled section
    local method_section=""
    for method in $methodologies; do
        method_section+="    - $method  # $(get_methodology_description "$method")\n"
    done

    # Enable/disable methodology sections
    for method in tdd bdd ddd agile; do
        if [[ " $methodologies " =~ " $method " ]]; then
            # Enable section (remove comment markers)
            sed -i "s/<!-- Enabled: false/<!-- Enabled: true/g" "$output_file"
            sed -i "/## \\[$method\\]/,/^---/ { s/<!--//g; s/-->//g }" "$output_file" 2>/dev/null || true
        fi
    done

    # Perform replacements
    sed -i "s/{project.name}/$project_name/g" "$output_file"
    sed -i "s/{project.type}/$project_type/g" "$output_file"
    sed -i "s/languages: \\[.*\\]/languages: [$lang_array]/g" "$output_file"
    sed -i "s/frameworks: \\[.*\\]/frameworks: [$fw_array]/g" "$output_file"
    sed -i "s/{tech_stack.languages}/$languages/g" "$output_file"
    sed -i "s/{tech_stack.frameworks}/$frameworks/g" "$output_file"
    sed -i "s/{methodologies.enabled}/$methodologies/g" "$output_file"
    sed -i "s/{team_rules.commit_convention}/$commit_convention/g" "$output_file"
    sed -i "s/{quality_gates.min_test_coverage}/$min_coverage/g" "$output_file"
    sed -i "s/{current_date}/$current_date/g" "$output_file"

    # Enable language-specific sections
    for lang in $languages; do
        case $lang in
            rust)
                sed -i "/## \\[Rust\\]/,/^---/ { s/<!--//g; s/-->//g }" "$output_file" 2>/dev/null || true
                ;;
            python)
                sed -i "/## \\[Python\\]/,/^---/ { s/<!--//g; s/-->//g }" "$output_file" 2>/dev/null || true
                ;;
            typescript|javascript)
                sed -i "/## \\[TypeScript\\]/,/^---/ { s/<!--//g; s/-->//g }" "$output_file" 2>/dev/null || true
                ;;
        esac
    done

    print_success "CLAUDE.md generated successfully at $output_file"
}

get_methodology_description() {
    case "$1" in
        tdd) echo "Test-Driven Development" ;;
        bdd) echo "Behavior-Driven Development" ;;
        ddd) echo "Domain-Driven Design" ;;
        clean-code) echo "Clean Code principles" ;;
        agile) echo "Agile/Scrum practices" ;;
        *) echo "" ;;
    esac
}

# Preset templates
create_preset() {
    local preset="$1"
    local project_dir="${2:-.}"

    case "$preset" in
        tdd)
            print_info "Creating TDD-focused CLAUDE.md (Kent Beck style)..."
            cp "${TEMPLATE_DIR}/tdd-preset.md" "${project_dir}/CLAUDE.md" 2>/dev/null || {
                # Fallback: generate from universal template
                generate_claude_md "TDD Project" "application" "rust" "" "" "tdd clean-code" "conventional-commits" "90"
            }
            ;;
        bdd)
            print_info "Creating BDD-focused CLAUDE.md..."
            generate_claude_md "BDD Project" "application" "typescript" "react" "" "bdd clean-code" "conventional-commits" "80"
            ;;
        ddd)
            print_info "Creating DDD-focused CLAUDE.md..."
            generate_claude_md "DDD Project" "service" "rust" "axum" "" "ddd tdd clean-code" "conventional-commits" "85"
            ;;
        fullstack)
            print_info "Creating Full-Stack CLAUDE.md..."
            generate_claude_md "Full-Stack Project" "application" "typescript rust" "react axum" "docker" "tdd clean-code" "conventional-commits" "80"
            ;;
        *)
            print_error "Unknown preset: $preset"
            echo "Available presets: tdd, bdd, ddd, fullstack"
            return 1
            ;;
    esac

    print_success "Preset CLAUDE.md created successfully"
}

# Main
main() {
    print_header

    case "${1:-interactive}" in
        --preset)
            shift
            create_preset "$@"
            ;;
        --help|-h)
            echo "Usage: claude-init [OPTIONS] [PROJECT_DIR]"
            echo ""
            echo "Options:"
            echo "  --preset <name>    Use a preset template (tdd, bdd, ddd, fullstack)"
            echo "  --help, -h         Show this help message"
            echo ""
            echo "Examples:"
            echo "  claude-init                    # Interactive setup in current directory"
            echo "  claude-init ~/my-project       # Interactive setup in specified directory"
            echo "  claude-init --preset tdd       # Use TDD preset"
            echo "  claude-init --preset ddd ~/api # Use DDD preset in ~/api"
            ;;
        *)
            interactive_setup
            ;;
    esac

    echo ""
    print_success "ðŸŽ‰ Setup complete!"
    echo ""
    print_info "Next steps:"
    echo "  1. Review and customize CLAUDE.md for your project"
    echo "  2. Commit CLAUDE.md to version control"
    echo "  3. Start coding with Claude Code!"
    echo ""
    print_info "Tip: Run 'claude-validate' to check your CLAUDE.md configuration"
}

main "$@"
